# ğŸ—ï¸ Architettura e Layout di Memoria

## Visualizzazione della Struttura

### 1. Struttura DinamicaArray in Memoria

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    MEMORY (Heap)                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚    DynamicArray struct (24 bytes)       â”‚             â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”‚
â”‚  â”‚  void** data  â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚             â”‚
â”‚  â”‚  size_t size = 3      â”‚                 â”‚             â”‚
â”‚  â”‚  size_t capacity = 4  â”‚                 â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                           â”‚                                â”‚
â”‚                           â–¼                                â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚    data[] array (4 * 8 = 32 bytes)     â”‚             â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤             â”‚
â”‚  â”‚  [0] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚             â”‚
â”‚  â”‚  [1] â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚             â”‚             â”‚
â”‚  â”‚  [2] â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚      â”‚             â”‚             â”‚
â”‚  â”‚  [3] = NULL   â”‚     â”‚      â”‚             â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚                  â”‚     â”‚      â”‚                           â”‚
â”‚                  â–¼     â–¼      â–¼                           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚  "Hello" â”‚ â”‚  42  â”‚ â”‚ 3.14 â”‚                          â”‚
â”‚  â”‚ (6 bytes)â”‚ â”‚(4 by)â”‚ â”‚(8 by)â”‚                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Stack:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ arr pointer â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â–º DynamicArray struct
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 2. Operazione PUSH - Step by Step

### Stato Iniziale
```
Array: capacity = 4, size = 4 (PIENO!)
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  0   1   2   3
          â–²
        size = 4
```

### Passo 1: Check CapacitÃ 
```
if (size >= capacity)  // 4 >= 4 = TRUE!
    â†’ Deve riallocare
```

### Passo 2: Calcolo Nuova CapacitÃ 
```
new_capacity = 4 * 2 = 8
```

### Passo 3: realloc (con possibile spostamento)
```
PRIMA:
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
0x1000

DOPO:
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚ ? â”‚ ? â”‚ ? â”‚ ? â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
0x2000  â† nuovo indirizzo!

memcpy dei dati:
  0x1000[0..3] â†’ 0x2000[0..3]
```

### Passo 4: Inserimento
```
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚ E â”‚ ? â”‚ ? â”‚ ? â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  0   1   2   3   4
                  â–²
                size = 5
```

## 3. Operazione INSERT - Shift Degli Elementi

### Inserire X in posizione 1
```
PRIMA: [A][B][C][D][?]
         0  1  2  3  4
                  â–²
                size = 4

PASSO 1: Shift da destra a sinistra
         for (i = size; i > index; i--)
             data[i] = data[i-1]

â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚ ? â”‚   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜ â†’ â”‚ A â”‚ B â”‚ C â”‚ D â”‚ D â”‚
  0   1   2   3   4     â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
                          0   1   2   3   4

â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚ ? â”‚ â†’ â”‚ A â”‚ C â”‚ C â”‚ D â”‚ D â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
                          0   1   2   3   4

â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚ ? â”‚ â†’ â”‚ A â”‚ B â”‚ B â”‚ C â”‚ D â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
                          0   1   2   3   4

PASSO 2: Inserisci X
         data[index] = X

â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ X â”‚ B â”‚ C â”‚ D â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  0   1   2   3   4
                  â–²
                size = 5
```

## 4. Operazione REMOVE - Shift Degli Elementi

### Rimuovere elemento in posizione 1
```
PRIMA: [A][B][C][D]
         0   1   2   3

PASSO 1: Salva elemento
         removed = data[1]  // B

PASSO 2: Shift da sinistra a destra
         for (i = index; i < size - 1; i++)
             data[i] = data[i+1]

â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ B â”‚ C â”‚ D â”‚ â†’ â”‚ A â”‚ C â”‚ C â”‚ D â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  0   1   2   3       0   1   2   3

â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”   â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”
â”‚ A â”‚ C â”‚ C â”‚ D â”‚ â†’ â”‚ A â”‚ C â”‚ D â”‚ D â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜   â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
  0   1   2   3       0   1   2   3

PASSO 3: Decrementa size
         size--

DOPO: [A][C][D][?]
        0   1   2   3
            â–²
          size = 3

  Note: D Ã¨ ancora in memoria a [3]
        ma non accessibile perchÃ© size = 3
```

## 5. Memory Leak - Cosa Succede

### Scenario di Memory Leak
```
Codice:
  DynamicArray *arr = dynamic_array_create(4);

  int *x = malloc(sizeof(int));  // Alloca 4 bytes
  *x = 42;
  dynamic_array_push(arr, x);

  // NON facciamo free(x)!
  dynamic_array_destroy(arr);    // Libera solo l'array

Memoria:
  PRIMA di destroy:
    Heap:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚ DynamicArray â”‚
    â”‚  (24 bytes)  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚ data[]       â”‚
    â”‚  (32 bytes)  â”‚
    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
    â”‚  x: 42       â”‚  â† Ancora allocato!
    â”‚  (4 bytes)   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  DOPO di destroy:
    Heap:
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  x: 42       â”‚  â† ORPHANED!
    â”‚  (4 bytes)   â”‚     Non piÃ¹ accessibile
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     ma ancora allocato

    â†’ MEMORY LEAK di 4 bytes!
```

### Correzione del Memory Leak
```
Codice corretto:
  DynamicArray *arr = dynamic_array_create(4);

  int *x = malloc(sizeof(int));
  *x = 42;
  dynamic_array_push(arr, x);

  // Libera PRIMA di destroy
  for (size_t i = 0; i < arr->size; i++) {
      free(arr->data[i]);  // Libera x
  }

  dynamic_array_destroy(arr);  // Libera l'array

Tutta la memoria Ã¨ liberata correttamente!
```

## 6. realloc - Il Comportamento

### Caso 1: Estensione In-Place (Migliore)
```
PRIMA:
Memory: [data][libero]
           4x8   4x8

realloc(data, 8 * 8) â†’ STESSO indirizzo!

DOPO:
Memory: [data     ]
           8x8

Tempo: O(1) - nessuna copia
```

### Caso 2: Riallocazione con Copia (Comune)
```
PRIMA:
Memory: [data][altro][libero]
           4x8   ...

realloc(data, 8 * 8) â†’ NUOVO indirizzo!

1. Alloca nuovo blocco
Memory: [data][altro][nuovo data]
           4x8            8x8

2. Copia i dati
memcpy(nuovo, vecchio, 4 * 8)

3. Libera vecchio
Memory: [libero][altro][nuovo data]
                  ...

DOPO:
Memory: [altro][nuovo data]
              8x8

Tempo: O(n) - deve copiare
```

### Caso 3: Fallimento (Pericolo!)
```
Codice pericoloso:
  arr->data = realloc(arr->data, new_size);
  // Se realloc fallisce â†’ NULL
  // arr->data = NULL â†’ DATI PERSI!

Codice sicuro:
  void **new_data = realloc(arr->data, new_size);
  if (new_data == NULL) {
      // arr->data ancora valido!
      return -1;
  }
  arr->data = new_data;  // OK
```

## 7. Stack vs Heap - Concetti Chiave

### Stack (Automatico)
```
Codice:
  void funzione() {
      int x = 5;
      char str[10];
      // ...
  }

Memoria:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Stack Frame   â”‚
  â”‚  x = 5        â”‚ â† nato quando entra in funzione
  â”‚  str[10]      â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     muore quando esce dalla funzione

Vantaggi:
  + Veloce (solo puntatore che sale/scende)
  + Auto-cleanup
  + Cache-friendly

Svantaggi:
  - Limitato (tipicamente 1-8 MB)
  - Dimensione fissa
  - Non puÃ² crescere dinamicamente
```

### Heap (Manuale)
```
Codice:
  void funzione() {
      int *x = malloc(sizeof(int));
      *x = 5;
      // ...
      free(x);
  }

Memoria:
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚ Heap          â”‚
  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
  â”‚  â”‚ x: 5    â”‚  â”‚ â† vive finchÃ© non fai free()
  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Vantaggi:
  + Grande (GB di memoria)
  + Dimensione dinamica
  + PuÃ² crescere (realloc)

Svantaggi:
  - Lento (gestione complessa)
  - Manuale cleanup
  - Memory leak se dimentichi free()
```

## 8. Timeline di una Variabile

### Stack Variable
```
â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ NATA    â”‚ int x = 5;  (allocazione automatica)
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ VIVA    â”‚ usata nel codice
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ MORTA   â”‚ } fine scope (deallocazione automatica)
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â–¼ tempo
```

### Heap Variable
```
â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ NATA    â”‚ int *p = malloc(sizeof(int));
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ VIVA    â”‚ *p = 5; usata nel codice
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ ZOMBIE  â”‚ dimentichi di fare free(p)
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â† MEMORY LEAK!
â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  â”‚ MORTA   â”‚ free(p); (DEVI farlo manualmente!)
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚
â–¼ tempo
```

---

**Ricorda**: In C, TU sei il responsabile della memoria! ğŸ’¾
